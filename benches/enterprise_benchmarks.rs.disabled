//! Enterprise-grade performance benchmarks

use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion};
use dbfast::{
    config::Config,
    errors::{DatabaseError, DbFastError, ErrorContext, ErrorSeverity},
};
use std::hint::black_box;

fn benchmark_error_creation(c: &mut Criterion) {
    c.bench_function("error_creation", |b| {
        b.iter(|| {
            black_box(DbFastError::Database {
                source: DatabaseError::ConnectionFailed {
                    details: "Connection timeout".to_string(),
                },
                context: Box::new(ErrorContext::new("benchmark", "database")
                    .with_severity(ErrorSeverity::High)
                    .with_detail("operation", "benchmark")),
            })
        })
    });
}

fn benchmark_error_formatting(c: &mut Criterion) {
    let error = DbFastError::Database {
        source: DatabaseError::QueryFailed {
            query: "SELECT * FROM users WHERE id = $1".to_string(),
        },
        context: Box::new(ErrorContext::new("query_execution", "database")
            .with_severity(ErrorSeverity::Medium)
            .with_detail("table", "users")
            .with_detail("user_id", "12345")),
    };

    c.bench_function("error_formatting", |b| {
        b.iter(|| black_box(format!("{}", error)))
    });
}

fn benchmark_config_operations(c: &mut Criterion) {
    c.bench_function("config_creation", |b| {
        b.iter(|| black_box(Config::new("test_repo", "test_template")))
    });
}

fn benchmark_error_context_builder(c: &mut Criterion) {
    c.bench_function("error_context_builder", |b| {
        b.iter(|| {
            black_box(
                ErrorContext::new("performance_test", "benchmark_module")
                    .with_severity(ErrorSeverity::Low)
                    .with_detail("test_type", "performance")
                    .with_detail("iteration", "1")
                    .with_detail("benchmark_name", "error_context_builder"),
            )
        })
    });
}

fn benchmark_batch_error_processing(c: &mut Criterion) {
    let mut group = c.benchmark_group("batch_error_processing");

    for size in [10, 100, 1000].iter() {
        group.bench_with_input(BenchmarkId::from_parameter(size), size, |b, &size| {
            b.iter(|| {
                let errors: Vec<DbFastError> = (0..size)
                    .map(|i| DbFastError::Database {
                        source: DatabaseError::Timeout {
                            operation: format!("operation_{}", i),
                        },
                        context: Box::new(ErrorContext::new("batch_test", "benchmark")
                            .with_detail("batch_size", &size.to_string())
                            .with_detail("item_index", &i.to_string())),
                    })
                    .collect();

                black_box(errors)
            })
        });
    }
    group.finish();
}

fn benchmark_concurrent_error_handling(c: &mut Criterion) {
    let rt = tokio::runtime::Runtime::new().unwrap();

    c.bench_function("concurrent_error_handling", |b| {
        b.iter(|| {
            let handles: Vec<_> = (0..10)
                .map(|i| {
                    tokio::spawn(async move {
                        DbFastError::Network {
                            message: format!("Network error {}", i),
                            context: Box::new(ErrorContext::new("concurrent_test", "network")
                                .with_severity(ErrorSeverity::Medium)
                                .with_detail("thread_id", &i.to_string())),
                        }
                    })
                })
                .collect();

            let results: Vec<_> = futures::future::join_all(handles).await;
            black_box(results)
        })
    });
}

criterion_group!(
    enterprise_benches,
    benchmark_error_creation,
    benchmark_error_formatting,
    benchmark_config_operations,
    benchmark_error_context_builder,
    benchmark_batch_error_processing,
    benchmark_concurrent_error_handling
);
criterion_main!(enterprise_benches);
